from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
 
# 生成私钥
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)
 
# 生成公钥
public_key = private_key.public_key()
 
# 将私钥保存到钱包（这里简化为字符串表示，实际应安全存储）
private_key_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.PKCS8,
    encryption_algorithm=serialization.NoEncryption()
)
 
# 获取公钥的PEM表示
public_key_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from datetime import datetime
 
# 考勤证书数据
student_id = "S12345"
event = "Class Attendance"
timestamp = datetime.utcnow().isoformat()
 
# 将数据序列化为字节
message = f"{student_id},{event},{timestamp}".encode()
 
# 使用私钥签名
signature = private_key.sign(
    message,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    hashes.SHA256()
)
 
# 将签名和证书数据打包成交易发送到区块链

古希腊掌管窝囊的神:
# 矿工验证签名
try:
    public_key.verify(
        signature,
        message,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    # 签名有效，可以打包到区块中
    print("Signature is valid.")
except Exception as e:
    # 签名无效，不能打包到区块中
    print("Signature is invalid.")
    print(e)

古希腊掌管窝囊的神:
# 假设有一个函数get_attendance_records可以从区块链获取记录
def get_attendance_records(student_id, start_date, end_date):
    # 实现查询逻辑
    pass
 
# 查询某个学生的考勤情况
records = get_attendance_records("S12345", "2023-01-01", "2023-12-31")
for record in records:
    print(record)

